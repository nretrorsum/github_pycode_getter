/.env
/notes.txt
/.venv
/.idea
# API Documentation and Project Overview

### Project Overview: Admin Dashboard for Telegram Bot

The project aims to develop an Admin Dashboard for a Telegram bot, providing a comprehensive interface for managing various bot functionalities. The primary features of the dashboard include user management, content management, automation of news publications, and technical settings, ensuring a streamlined experience for administrators.

Currently, the frontend is still under development, with several components being designed to enhance user interaction. Meanwhile, some aspects of the backend require attention to optimize performance and functionality. Despite these areas needing further refinement, the core functionalities are operating smoothly, allowing for effective management of the Telegram bot.

## Screenshots of current functionality
![Login page](https://github.com/nretrorsum/admin_project/blob/master/img/login_page.png)
![Dashboard page](https://github.com/nretrorsum/admin_project/blob/master/img/dashboard_page.png)

# API Documentation

## Authentication Endpoints

### POST /auth/login_page
Returns the login page for the application.

**Response**: Renders the login HTML template.

---

### POST /auth/register
Registers a new user.

**Request Body**:
```json
{
    "id": 1,
    "first_name": "string",
    "last_name": "string",
    "email": "string",
    "hashed_password": "string",
    "tariff_id": 1,
    "is_active": true
}
```

**Response**:
```json
{
    "message": "User created successfully"
}
```

**HTTP Status Codes**:
- **201 Created**: User registered successfully.
- **400 Bad Request**: Invalid input data.

---

### POST /auth/token
Generates an access token for the user.

**Request Body** (form-data):
- username: User's email.
- password: User's password.

**Response**:
```json
{
    "access_token": "string",
    "token_type": "Bearer"
}
```

**HTTP Status Codes**:
- **200 OK**: Token created successfully.
- **401 Unauthorized**: Could not authenticate user (invalid credentials).

---

## User Endpoints

### GET /users/user/{id}
Fetches user data by ID.

**Response**:
```json
{
    "id": 1,
    "first_name": "string",
    "last_name": "string",
    "email": "string",
    "tariff_id": 1,
    "is_active": true
}
```

**HTTP Status Codes**:
- **200 OK**: User data retrieved successfully.
- **401 Unauthorized**: Not authenticated.
- **403 Forbidden**: User does not have permission to access this resource.
- **404 Not Found**: User not found.

---

### GET /users/{id}/tariff
Fetches the tariff information for a user by ID.

**Response**:
```json
{
    "id": 1,
    "email": "string",
    "tariff_id": 1,
    "tag": "string",
    "start_time": "2023-01-01T00:00:00",
    "end_time": "2024-01-01T00:00:00"
}
```

**HTTP Status Codes**:
- **200 OK**: Tariff data retrieved successfully.
- **401 Unauthorized**: Not authenticated.
- **403 Forbidden**: User does not have permission to access this resource.
- **404 Not Found**: User with tariff not found.

---

### GET /users/publications/{id}
Fetches the publications for a user by ID.

**Response**:
```json
[
    {
        "id": 1,
        "title": "string",
        "content": "string",
        "user_id": 1
    },
    ...
]
```

**HTTP Status Codes**:
- **200 OK**: Publications retrieved successfully.
- **401 Unauthorized**: Not authenticated.
- **403 Forbidden**: User does not have permission to access this resource.
- **404 Not Found**: User with publications not found.

---

### POST /users/change_tariff/{id}
Changes the user's tariff.

**Request Body**:
```json
{
    "new_tariff_id": 2
}
```

**Response**:
```json
{
    "new_tariff_id": 2,
    "time": "2023-01-01T00:00:00"
}
```

**HTTP Status Codes**:
- **200 OK**: Tariff changed successfully.
- **401 Unauthorized**: Not authenticated.
- **403 Forbidden**: User does not have permission to access this resource.

---

### POST /users/recover_password/{id}
Recovers the user's password.

**Request Body**:
```json
{
    "password": "new_password"
}
```

**Response**:
```json
{
    "new_password": "hashed_password",
    "time": "2023-01-01T00:00:00"
}
```

**HTTP Status Codes**:
- **200 OK**: Password recovered successfully.
- **401 Unauthorized**: Not authenticated.
- **403 Forbidden**: User does not have permission to access this resource.

---

## General Endpoints

### GET /
Renders the main login page.

**Response**: Renders the login HTML template.

---

### GET /dashboard
Renders the dashboard page for authenticated users.

**Response**: Renders the dashboard HTML template.

---

## Error Codes
### 4XX Errors
- **400 Bad Request**: The request was invalid, often due to missing or incorrect parameters.
- **401 Unauthorized**: The user is not authenticated. Typically occurs when the user has not logged in or the provided token is invalid.
- **403 Forbidden**: The user does not have permission to access the requested resource.
- **404 Not Found**: The requested resource could not be found.

### Successful Codes
- **200 OK**: The request was successful, and the server returned the requested data.
- **201 Created**: The request was successful, and a new resource was created as a result.
# A generic, single database configuration.

[alembic]
# path to migration scripts
# Use forward slashes (/) also on windows to provide an os agnostic path
script_location = migrations

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python>=3.9 or backports.zoneinfo library.
# Any required deps can installed by adding `alembic[tz]` to the pip requirements
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to migrations/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "version_path_separator" below.
# version_locations = %(here)s/bar:%(here)s/bat:migrations/versions

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses os.pathsep.
# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
# version_path_separator = newline
version_path_separator = os  # Use os.pathsep. Default configuration used for new projects.

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

sqlalchemy.url = postgresql+asyncpg://%(DB_USER)s:%(DB_PASS)s@%(DB_HOST)s:%(DB_PORT)s/%(DB_NAME)s?async_fallback=True


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the exec runner, execute a binary
# hooks = ruff
# ruff.type = exec
# ruff.executable = %(here)s/.venv/bin/ruff
# ruff.options = --fix REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
import os
from calendar import month
from datetime import timedelta, datetime
from typing import Annotated, TypeVar

from sqlalchemy.orm import Session
from fastapi.security import OAuth2PasswordRequestForm, OAuth2PasswordBearer
from pydantic import BaseModel
from fastapi import APIRouter, Depends, HTTPException, Request
from database.models import User_Table
from passlib.context import CryptContext
from starlette import status
from database.database import async_session_maker
from sqlalchemy.future import select
from jose import jwt, JWTError
from fastapi.templating import Jinja2Templates
from config import SECRET_KEY, ALGORITHM
from auth.schemas import CreateUserRequest, Token

auth_router = APIRouter()

templates = Jinja2Templates(directory="templates")


bcrypt_context = CryptContext(schemes=['bcrypt'], deprecated='auto')
oauth2_bearer = OAuth2PasswordBearer(tokenUrl='/auth/token')

async def get_db():
    async with async_session_maker() as session:
        yield session

db_dependency = Annotated[Session, Depends(get_db)]



async def authenticate_user(username: str, password: str, db):
    query = select(User_Table).where(User_Table.email == username)
    result = await db.execute(query)
    user = result.scalars().first()

    if not user:
        return False
    if not bcrypt_context.verify(password, user.hashed_password):
        return False

    return user

async def create_jwt_token(email: str, user_id: int, expires_delta: timedelta):
    encode = {'sub': email, 'id': user_id}
    expires = datetime.utcnow() + expires_delta
    encode.update({'exp': expires})
    return jwt.encode(encode, SECRET_KEY, algorithm=ALGORITHM)

async def get_current_user(token: Annotated[str, Depends(oauth2_bearer)]):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        email: str = payload.get('sub')
        user_id: int = payload.get('id')
        if email is None or user_id is None:
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail='Could not authenticate user')
        return {'email': email, 'user_id': user_id}
    except JWTError:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,
                            detail='Could not authenticate user')


@auth_router.post('/login_page')
async def request_login_page(request: Request):
    return templates.TemplateResponse('login.html', {'request': request})


@auth_router.post('/register', status_code=status.HTTP_201_CREATED)
async def register_user(request: CreateUserRequest, db: db_dependency):
    expiration = timedelta(weeks=4)

    create_user_model = User_Table(
        id=request.id,
        first_name=request.first_name,
        last_name=request.last_name,
        email=request.email,
        hashed_password=bcrypt_context.hash(request.hashed_password),
        tariff_id=request.tariff_id,
        start_time= datetime.utcnow(),
        end_time= datetime.utcnow() + expiration,
        is_active=True,
    )
    db.add(create_user_model)
    await db.commit()

    return {"message": "User created successfully"}

@auth_router.post('/token', response_model=Token)
async def create_access_token(form_data: Annotated[OAuth2PasswordRequestForm, Depends()], db: db_dependency):
    user = await authenticate_user(form_data.username, form_data.password, db)
    if not user:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,
                            detail='Could not authenticate user')
    token = await create_jwt_token(user.email, user.id, timedelta(minutes=60))
    return {'access_token': token, 'token_type': 'Bearer', 'user_id': user.id}
from pydantic import BaseModel
from typing import Optional
from datetime import datetime

class CreateUserRequest(BaseModel):
    id: int
    first_name: str
    last_name: str
    email: str
    hashed_password: str
    tariff_id: Optional[int] = 1
    start_time: datetime
    end_time: datetime
    is_active: bool

class Token(BaseModel):
    access_token: str
    token_type: str
    user_id: int
from dotenv import load_dotenv
import os


load_dotenv()

DB_NAME = os.environ.get('DB_NAME')
DB_USER = os.environ.get('DB_USER')
DB_PASS = os.environ.get('DB_PASS')
DB_HOST = os.environ.get('DB_HOST')
DB_PORT = os.environ.get('DB_PORT')
SECRET_KEY = os.environ.get('SECRET_KEY')
ALGORITHM = os.environ.get('ALGORITHM')from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from typing import AsyncGenerator

from config import DB_PASS, DB_HOST, DB_NAME, DB_PORT, DB_USER

DATABASE_URL = f"postgresql+asyncpg://{DB_USER}:{DB_PASS}@{DB_HOST}:{DB_PORT}/{DB_NAME}"

engine = create_async_engine(DATABASE_URL)
async_session_maker = async_sessionmaker(bind=engine, class_=AsyncSession, expire_on_commit=False, autocommit=False)




from sqlalchemy import Integer, String, ForeignKey, DateTime, Boolean
from sqlalchemy.orm import DeclarativeBase, relationship, mapped_column


class Base(DeclarativeBase):
    pass

class User_Table(Base):
    __tablename__ = 'users'

    id = mapped_column(Integer, primary_key=True)
    first_name = mapped_column(String)
    last_name = mapped_column(String)
    email = mapped_column(String, unique=True)
    hashed_password = mapped_column(String)
    telegram_id = mapped_column(Integer, unique=True)
    tariff_id = mapped_column(Integer, ForeignKey('tariffs.id'))
    start_time = mapped_column(DateTime)
    end_time = mapped_column(DateTime)
    is_active = mapped_column(Boolean)

    tariff = relationship("Tariff", back_populates="users")
    subscriptions = relationship("Subscriptions", back_populates="users")
    publications = relationship("Publications", back_populates="users")

class Tariff(Base):
   __tablename__ = 'tariffs'
   id = mapped_column(Integer, primary_key=True)
   tag = mapped_column(String)
   price = mapped_column(Integer)

   users = relationship("User_Table", back_populates="tariff")

class Subscriptions(Base):
    __tablename__ = 'subscriptions'

    id = mapped_column(Integer, primary_key=True)
    user_id = mapped_column(Integer, ForeignKey('users.id'))
    channel_id = mapped_column(Integer)

    users = relationship("User_Table", back_populates="subscriptions")

class Publications(Base):
    __tablename__ = 'publications'
    id = mapped_column(Integer, primary_key=True)
    user_id = mapped_column(Integer, ForeignKey('users.id'))
    channel_id = mapped_column(Integer)
    text = mapped_column(String)
    time = mapped_column(DateTime)

    users = relationship("User_Table", back_populates="publications")from fastapi import FastAPI, Request
from operations.routers import user_router
from auth.auth import auth_router
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

origins = [
    "http://localhost",
    "http://localhost:8000",
    "http://127.0.0.1:8000"
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_headers=["*"],
)

templates = Jinja2Templates(directory="templates")
app.mount('/static', StaticFiles(directory='static'), name='static')

app.include_router(
    auth_router,
    prefix="/auth",
    tags=["Auth"]
)

app.include_router(
    user_router,
    prefix="/users",
    tags=["Users"]
)

@app.get('/')
async def test(request: Request):
    return templates.TemplateResponse('login.html', {"request": request})

@app.get('/dashboard')
async def test(request: Request):
    return templates.TemplateResponse('dashboard.html', {"request": request, 'is_dashboard': True})Generic single-database configuration.from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context
from config import DB_PASS, DB_USER, DB_HOST, DB_PORT, DB_NAME
from database.models import Base
# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

section = config.config_ini_section
config.set_section_option(section, 'DB_HOST',DB_HOST)
config.set_section_option(section, 'DB_PORT', DB_PORT)
config.set_section_option(section, 'DB_PASS', DB_PASS)
config.set_section_option(section, 'DB_USER', DB_USER)
config.set_section_option(section, 'DB_NAME', DB_NAME)

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = Base.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision: str = ${repr(up_revision)}
down_revision: Union[str, None] = ${repr(down_revision)}
branch_labels: Union[str, Sequence[str], None] = ${repr(branch_labels)}
depends_on: Union[str, Sequence[str], None] = ${repr(depends_on)}


def upgrade() -> None:
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    ${downgrades if downgrades else "pass"}
"""relationship fix

Revision ID: 0ee98daac54e
Revises: 209f7d13becd
Create Date: 2024-10-17 23:54:55.086595

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '0ee98daac54e'
down_revision: Union[str, None] = '209f7d13becd'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
"""relationship fix

Revision ID: 209f7d13becd
Revises: 527b0e4a414c
Create Date: 2024-10-17 23:40:29.538927

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '209f7d13becd'
down_revision: Union[str, None] = '527b0e4a414c'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
"""relationship fix

Revision ID: 24365a15da91
Revises: 54395c99219f
Create Date: 2024-10-18 16:05:27.952351

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '24365a15da91'
down_revision: Union[str, None] = '54395c99219f'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
"""db init

Revision ID: 3cc2228c15ef
Revises: e084aa8e7ec6
Create Date: 2024-10-30 22:32:12.396975

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '3cc2228c15ef'
down_revision: Union[str, None] = 'e084aa8e7ec6'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('tariffs',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('tag', sa.String(), nullable=True),
    sa.Column('price', sa.Integer(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('users',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('first_name', sa.String(), nullable=True),
    sa.Column('last_name', sa.String(), nullable=True),
    sa.Column('email', sa.String(), nullable=True),
    sa.Column('hashed_password', sa.String(), nullable=True),
    sa.Column('telegram_id', sa.Integer(), nullable=True),
    sa.Column('tariff_id', sa.Integer(), nullable=True),
    sa.Column('start_time', sa.DateTime(), nullable=True),
    sa.Column('end_time', sa.DateTime(), nullable=True),
    sa.Column('is_active', sa.Boolean(), nullable=True),
    sa.ForeignKeyConstraint(['tariff_id'], ['tariffs.id'], ),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('email'),
    sa.UniqueConstraint('telegram_id')
    )
    op.create_table('publications',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=True),
    sa.Column('channel_id', sa.Integer(), nullable=True),
    sa.Column('text', sa.String(), nullable=True),
    sa.Column('time', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('subscriptions',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=True),
    sa.Column('channel_id', sa.Integer(), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('subscriptions')
    op.drop_table('publications')
    op.drop_table('users')
    op.drop_table('tariffs')
    # ### end Alembic commands ###
"""relationship fix

Revision ID: 438a0a2e5046
Revises: 0ee98daac54e
Create Date: 2024-10-17 23:56:48.676458

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '438a0a2e5046'
down_revision: Union[str, None] = '0ee98daac54e'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
"""relationship fix

Revision ID: 527b0e4a414c
Revises: a0bce865ce2e
Create Date: 2024-10-17 23:36:30.792878

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '527b0e4a414c'
down_revision: Union[str, None] = 'a0bce865ce2e'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('users', sa.Column('is_active', sa.Boolean(), nullable=True))
    op.add_column('users', sa.Column('is_superuser', sa.Boolean(), nullable=True))
    op.add_column('users', sa.Column('is_verified', sa.Boolean(), nullable=True))
    op.add_column('users', sa.Column('hashed_password', sa.String(length=1024), nullable=False))
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('users', 'hashed_password')
    op.drop_column('users', 'is_verified')
    op.drop_column('users', 'is_superuser')
    op.drop_column('users', 'is_active')
    # ### end Alembic commands ###
"""relationship fix

Revision ID: 54395c99219f
Revises: d331f8342742
Create Date: 2024-10-18 15:54:25.262408

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '54395c99219f'
down_revision: Union[str, None] = 'd331f8342742'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('users', sa.Column('hashed_password', sa.String(), nullable=True))
    op.drop_column('users', 'password')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('users', sa.Column('password', sa.VARCHAR(), autoincrement=False, nullable=True))
    op.drop_column('users', 'hashed_password')
    # ### end Alembic commands ###
"""relationship fix

Revision ID: 59ecb2e88238
Revises: 438a0a2e5046
Create Date: 2024-10-18 00:27:53.953978

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '59ecb2e88238'
down_revision: Union[str, None] = '438a0a2e5046'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('users', 'hashed_password')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('users', sa.Column('hashed_password', sa.VARCHAR(length=1024), autoincrement=False, nullable=False))
    # ### end Alembic commands ###
"""table user update

Revision ID: 90c18ea568d1
Revises: 96ced32a7ae8
Create Date: 2024-10-21 19:55:00.612688

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '90c18ea568d1'
down_revision: Union[str, None] = '96ced32a7ae8'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_unique_constraint(None, 'users', ['telegram_id'])
    op.create_unique_constraint(None, 'users', ['email'])
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(None, 'users', type_='unique')
    op.drop_constraint(None, 'users', type_='unique')
    # ### end Alembic commands ###
"""relationship fix

Revision ID: 96ced32a7ae8
Revises: d5719260106c
Create Date: 2024-10-20 13:47:30.089696

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = '96ced32a7ae8'
down_revision: Union[str, None] = 'd5719260106c'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('user',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('first_name', sa.String(), nullable=True),
    sa.Column('last_name', sa.String(), nullable=True),
    sa.Column('email', sa.String(), nullable=True),
    sa.Column('hashed_password', sa.String(), nullable=True),
    sa.Column('telegram_id', sa.Integer(), nullable=True),
    sa.Column('tariff_id', sa.Integer(), nullable=True),
    sa.Column('start_time', sa.DateTime(), nullable=True),
    sa.Column('end_time', sa.DateTime(), nullable=True),
    sa.Column('is_active', sa.Boolean(), nullable=True),
    sa.Column('is_superuser', sa.Boolean(), nullable=True),
    sa.Column('is_verified', sa.Boolean(), nullable=True),
    sa.ForeignKeyConstraint(['tariff_id'], ['tariffs.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.drop_table('users')
    op.drop_constraint('subscriptions_user_id_fkey', 'subscriptions', type_='foreignkey')
    op.create_foreign_key(None, 'subscriptions', 'user', ['user_id'], ['id'])
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(None, 'subscriptions', type_='foreignkey')
    op.create_foreign_key('subscriptions_user_id_fkey', 'subscriptions', 'users', ['user_id'], ['id'])
    op.create_table('users',
    sa.Column('id', sa.INTEGER(), autoincrement=True, nullable=False),
    sa.Column('first_name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('last_name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('email', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('telegram_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('tariff_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('start_time', postgresql.TIMESTAMP(), autoincrement=False, nullable=True),
    sa.Column('end_time', postgresql.TIMESTAMP(), autoincrement=False, nullable=True),
    sa.Column('is_active', sa.BOOLEAN(), autoincrement=False, nullable=True),
    sa.Column('is_superuser', sa.BOOLEAN(), autoincrement=False, nullable=True),
    sa.Column('is_verified', sa.BOOLEAN(), autoincrement=False, nullable=True),
    sa.Column('hashed_password', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['tariff_id'], ['tariffs.id'], name='users_tariff_id_fkey'),
    sa.PrimaryKeyConstraint('id', name='users_pkey')
    )
    op.drop_table('user')
    # ### end Alembic commands ###
"""Initial migration

Revision ID: a0bce865ce2e
Revises: 
Create Date: 2024-10-17 17:21:27.434328

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'a0bce865ce2e'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('tariffs',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('tag', sa.String(), nullable=True),
    sa.Column('price', sa.Integer(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('techs',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('topic_name', sa.String(), nullable=True),
    sa.Column('channel_name', sa.String(), nullable=True),
    sa.Column('channel_url', sa.String(), nullable=True),
    sa.Column('last_pub_time', sa.DateTime(), nullable=True),
    sa.Column('user_id', sa.Integer(), nullable=True),
    sa.Column('news_type', sa.String(), nullable=True),
    sa.Column('publish_frequency', sa.Integer(), nullable=True),
    sa.Column('language_code', sa.String(), nullable=True),
    sa.Column('add_poll', sa.String(), nullable=True),
    sa.Column('is_active', sa.Boolean(), nullable=True),
    sa.Column('poll_text', sa.String(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('users',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('first_name', sa.String(), nullable=True),
    sa.Column('last_name', sa.String(), nullable=True),
    sa.Column('email', sa.String(), nullable=True),
    sa.Column('password', sa.String(), nullable=True),
    sa.Column('telegram_id', sa.Integer(), nullable=True),
    sa.Column('tariff_id', sa.Integer(), nullable=True),
    sa.Column('start_time', sa.DateTime(), nullable=True),
    sa.Column('end_time', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['tariff_id'], ['tariffs.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('subscriptions',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=True),
    sa.Column('channel_id', sa.Integer(), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('subscriptions')
    op.drop_table('users')
    op.drop_table('techs')
    op.drop_table('tariffs')
    # ### end Alembic commands ###
"""db update

Revision ID: a8afb91bfc8b
Revises: 90c18ea568d1
Create Date: 2024-10-28 20:42:36.049699

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = 'a8afb91bfc8b'
down_revision: Union[str, None] = '90c18ea568d1'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('techs')
    op.drop_column('users', 'is_verified')
    op.drop_column('users', 'is_superuser')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('users', sa.Column('is_superuser', sa.BOOLEAN(), autoincrement=False, nullable=True))
    op.add_column('users', sa.Column('is_verified', sa.BOOLEAN(), autoincrement=False, nullable=True))
    op.create_table('techs',
    sa.Column('id', sa.INTEGER(), autoincrement=True, nullable=False),
    sa.Column('topic_name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('channel_name', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('channel_url', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('last_pub_time', postgresql.TIMESTAMP(), autoincrement=False, nullable=True),
    sa.Column('user_id', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('news_type', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('publish_frequency', sa.INTEGER(), autoincrement=False, nullable=True),
    sa.Column('language_code', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('add_poll', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.Column('is_active', sa.BOOLEAN(), autoincrement=False, nullable=True),
    sa.Column('poll_text', sa.VARCHAR(), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('id', name='techs_pkey')
    )
    # ### end Alembic commands ###
"""relationship fix

Revision ID: af34ce7f08c0
Revises: da3d692ef9a3
Create Date: 2024-10-18 17:24:18.618404

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'af34ce7f08c0'
down_revision: Union[str, None] = 'da3d692ef9a3'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
"""models fix

Revision ID: b0d5bc8aa52a
Revises: af34ce7f08c0
Create Date: 2024-10-20 13:16:23.084997

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'b0d5bc8aa52a'
down_revision: Union[str, None] = 'af34ce7f08c0'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
"""relationship fix

Revision ID: cbf242d1c757
Revises: 59ecb2e88238
Create Date: 2024-10-18 00:55:45.270075

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'cbf242d1c757'
down_revision: Union[str, None] = '59ecb2e88238'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
"""relationship fix

Revision ID: d331f8342742
Revises: e89d6e9da66f
Create Date: 2024-10-18 01:03:12.632331

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'd331f8342742'
down_revision: Union[str, None] = 'e89d6e9da66f'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
"""relationship fix

Revision ID: d5719260106c
Revises: b0d5bc8aa52a
Create Date: 2024-10-20 13:29:00.988204

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'd5719260106c'
down_revision: Union[str, None] = 'b0d5bc8aa52a'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
"""relationship fix

Revision ID: da3d692ef9a3
Revises: 24365a15da91
Create Date: 2024-10-18 16:39:39.800491

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'da3d692ef9a3'
down_revision: Union[str, None] = '24365a15da91'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
"""tables admin_project init

Revision ID: dd3b8208e4fe
Revises: 3cc2228c15ef
Create Date: 2024-10-31 20:04:52.101552

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'dd3b8208e4fe'
down_revision: Union[str, None] = '3cc2228c15ef'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('tariffs',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('tag', sa.String(), nullable=True),
    sa.Column('price', sa.Integer(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('users',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('first_name', sa.String(), nullable=True),
    sa.Column('last_name', sa.String(), nullable=True),
    sa.Column('email', sa.String(), nullable=True),
    sa.Column('hashed_password', sa.String(), nullable=True),
    sa.Column('telegram_id', sa.Integer(), nullable=True),
    sa.Column('tariff_id', sa.Integer(), nullable=True),
    sa.Column('start_time', sa.DateTime(), nullable=True),
    sa.Column('end_time', sa.DateTime(), nullable=True),
    sa.Column('is_active', sa.Boolean(), nullable=True),
    sa.ForeignKeyConstraint(['tariff_id'], ['tariffs.id'], ),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('email'),
    sa.UniqueConstraint('telegram_id')
    )
    op.create_table('publications',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=True),
    sa.Column('channel_id', sa.Integer(), nullable=True),
    sa.Column('text', sa.String(), nullable=True),
    sa.Column('time', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('subscriptions',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=True),
    sa.Column('channel_id', sa.Integer(), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('subscriptions')
    op.drop_table('publications')
    op.drop_table('users')
    op.drop_table('tariffs')
    # ### end Alembic commands ###
"""db init

Revision ID: e084aa8e7ec6
Revises: a8afb91bfc8b
Create Date: 2024-10-30 22:29:27.144985

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = 'e084aa8e7ec6'
down_revision: Union[str, None] = 'a8afb91bfc8b'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('tariffs',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('tag', sa.String(), nullable=True),
    sa.Column('price', sa.Integer(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('users',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('first_name', sa.String(), nullable=True),
    sa.Column('last_name', sa.String(), nullable=True),
    sa.Column('email', sa.String(), nullable=True),
    sa.Column('hashed_password', sa.String(), nullable=True),
    sa.Column('telegram_id', sa.Integer(), nullable=True),
    sa.Column('tariff_id', sa.Integer(), nullable=True),
    sa.Column('start_time', sa.DateTime(), nullable=True),
    sa.Column('end_time', sa.DateTime(), nullable=True),
    sa.Column('is_active', sa.Boolean(), nullable=True),
    sa.ForeignKeyConstraint(['tariff_id'], ['tariffs.id'], ),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('email'),
    sa.UniqueConstraint('telegram_id')
    )
    op.create_table('publications',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=True),
    sa.Column('channel_id', sa.Integer(), nullable=True),
    sa.Column('text', sa.String(), nullable=True),
    sa.Column('time', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('subscriptions',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=True),
    sa.Column('channel_id', sa.Integer(), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.drop_index('ix_user_email', table_name='user')
    op.drop_table('user')
    op.drop_index('ix_post_title', table_name='post')
    op.drop_table('post')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('post',
    sa.Column('title', sa.VARCHAR(length=100), autoincrement=False, nullable=False),
    sa.Column('content', sa.VARCHAR(length=5000), autoincrement=False, nullable=False),
    sa.Column('created', postgresql.TIMESTAMP(), autoincrement=False, nullable=False),
    sa.Column('updated', postgresql.TIMESTAMP(), autoincrement=False, nullable=True),
    sa.Column('likes', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('dislikes', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('author_id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('id', sa.INTEGER(), autoincrement=True, nullable=False),
    sa.ForeignKeyConstraint(['author_id'], ['user.id'], name='fk_post_author_id_user'),
    sa.PrimaryKeyConstraint('id', name='pk_post')
    )
    op.create_index('ix_post_title', 'post', ['title'], unique=True)
    op.create_table('user',
    sa.Column('email', sa.VARCHAR(length=320), autoincrement=False, nullable=False),
    sa.Column('hashed_password', sa.VARCHAR(length=1024), autoincrement=False, nullable=False),
    sa.Column('is_active', sa.BOOLEAN(), autoincrement=False, nullable=False),
    sa.Column('is_superuser', sa.BOOLEAN(), autoincrement=False, nullable=False),
    sa.Column('is_verified', sa.BOOLEAN(), autoincrement=False, nullable=False),
    sa.Column('id', sa.INTEGER(), autoincrement=True, nullable=False),
    sa.PrimaryKeyConstraint('id', name='pk_user')
    )
    op.create_index('ix_user_email', 'user', ['email'], unique=True)
    op.drop_table('subscriptions')
    op.drop_table('publications')
    op.drop_table('users')
    op.drop_table('tariffs')
    # ### end Alembic commands ###
"""relationship fix

Revision ID: e89d6e9da66f
Revises: f641c66aecb2
Create Date: 2024-10-18 00:58:15.879391

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'e89d6e9da66f'
down_revision: Union[str, None] = 'f641c66aecb2'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
"""relationship fix

Revision ID: f641c66aecb2
Revises: cbf242d1c757
Create Date: 2024-10-18 00:56:52.667679

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'f641c66aecb2'
down_revision: Union[str, None] = 'cbf242d1c757'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
from datetime import datetime

from pydantic import BaseModel
from typing import Optional

class TariffResponse(BaseModel):
    id: int
    tag: str
    price: int


class GetUserModel(BaseModel):
    id: int
    first_name: str
    last_name: str
    email: str
    tariff: Optional[TariffResponse]
    start_time: datetime
    end_time: datetime

class GetUserPublications(BaseModel):
    id: int
    user_id: int
    channel_id: int
    text: str
    time: Optional[datetime] = None

class ChangeUserTariff(BaseModel):
    new_tariff_id: int
    time: Optional[datetime] = None

class RecoverUserPassword(BaseModel):
    new_password: str
    time: Optional[datetime] = None
from datetime import datetime
from http.client import HTTPException
from typing import List, Annotated
from auth.auth import get_current_user
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from auth.auth import get_db
from sqlalchemy.future import select
from database.models import User_Table, Tariff, Publications
from operations.response_models import GetUserModel, GetUserPublications, ChangeUserTariff, \
    RecoverUserPassword
from auth.auth import bcrypt_context
from sqlalchemy.orm import selectinload

user_router = APIRouter()

user_dependency = Annotated[dict, Depends(get_current_user)]

@user_router.get("/user/{id}", response_model=GetUserModel)
async def get_user(user: user_dependency, id: int, session: AsyncSession = Depends(get_db)):
    if user is None:
        raise HTTPException(status_code=401, detail="Not authenticated")

    #print("Authenticated user data:", user)

    if user['user_id'] != id:
        raise HTTPException(
            status_code=403,
            detail="You do not have permission to access this resource."
        )

    result = await session.execute(
        select(User_Table)
        .options(selectinload(User_Table.tariff))  #   
        .where(User_Table.id == id)
    )

    user = result.scalar_one_or_none()
    if user is None:
        raise HTTPException(status_code=404, detail="User not found")

    return user


@user_router.get("/publications/{id}", response_model=List[GetUserPublications])
async def get_user_publications(user: user_dependency,id: int, session: AsyncSession = Depends(get_db)):
    if user is None:
        raise HTTPException(status_code=401, detail="Not authenticated")

    if user['user_id'] != id:
        raise HTTPException(
            status_code=403,
            detail="You do not have permission to access this resource."
        )

    result = await session.execute(
        select(Publications)
        .where(Publications.user_id == id)
    )

    user_publications = result.scalars().all()
    if not user_publications:
        raise HTTPException(status_code=404, detail="User with publications not found")
    else:
        return user_publications

@user_router.post("/change_tariff/{id}", response_model=ChangeUserTariff)
async def change_user_tariff(
    user: user_dependency,
    id: int,
    tariff_data: ChangeUserTariff,
    session: AsyncSession = Depends(get_db)
):
    if user is None:
        raise HTTPException(status_code=401, detail="Not authenticated")

    if user['user_id'] != id:
        raise HTTPException(
            status_code=403,
            detail="You do not have permission to access this resource."
        )

    await session.execute(
        User_Table.__table__.update()
        .where(User_Table.id == id)
        .values(tariff_id=tariff_data.new_tariff_id)
    )

    await session.commit()

    return ChangeUserTariff(
        new_tariff_id=tariff_data.new_tariff_id,
        time=datetime.utcnow()
    )

@user_router.post("/user/recover_password/{id}", response_model=RecoverUserPassword)
async def recover_password(user:user_dependency, id: int, password: str, session: AsyncSession = Depends(get_db)):
    if user is None:
        raise HTTPException(status_code=401, detail="Not authenticated")

    if user['user_id'] != id:
        raise HTTPException(status_code=403, detail="You do not have permission to access this resource.")

    await session.execute(
        User_Table.__table__.update()
        .where(User_Table.id == id)
        .values(hashed_password = bcrypt_context.hash(password))
    )

    await session.commit()

    return RecoverUserPassword(
        new_password=bcrypt_context.hash(password),
        time=datetime.utcnow()
    )* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: Arial, sans-serif;
    color: #E0E0E0;
    background-color: #121212;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

h1, h2, h3, h4, h5, h6 {
    color: #E0E0E0;
    margin-bottom: 15px;
    font-weight: 700;
    background-color: #1F1F1F;
    padding: 10px;
    border-radius: 5px;
}

p, li {
    line-height: 1.6;
    color: #B0B0B0;
}

a {
    color: #C8C8C8;
    text-decoration: none;
}

a:hover {
    color: #FFFFFF;
    text-decoration: underline;
}

button, .button {
    padding: 10px 20px;
    color: #E0E0E0;
    background-color: #1F1F1F;
    border: none;
    cursor: pointer;
    font-weight: bold;
    border-radius: 5px;
}

button:hover, .button:hover {
    background-color: #333333;
}

nav {
    background-color: #1F1F1F;
    padding: 15px;
    text-align: center;
}

nav a {
    color: #C0C0C0;
    margin: 0 15px;
    font-weight: bold;
}

nav a:hover {
    color: #FFFFFF;
}

footer {
    background-color: #1F1F1F;
    color: #8D8D8D;
    text-align: center;
    padding: 20px;
    font-size: 0.9em;
}

.card {
    background-color: #1F1F1F;
    padding: 20px;
    margin: 15px;
    border-radius: 5px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.card h3 {
    color: #E0E0E0;
}

.card p {
    color: #B0B0B0;
}

form {
    background-color: #1F1F1F;
    padding: 20px;
    border-radius: 5px;
}

input, textarea {
    width: 100%;
    padding: 10px;
    margin: 10px 0;
    border: none;
    background-color: #2E2E2E;
    color: #E0E0E0;
    border-radius: 5px;
}

input::placeholder, textarea::placeholder {
    color: #7F7F7F;
}

ul, ol {
    color: #B0B0B0;
    margin: 20px 0;
    padding-left: 20px;
}

li {
    margin-bottom: 10px;
}

.section {
    margin: 40px 0;
    padding: 20px;
    background-color: #1A1A1A;
    border-radius: 8px;
}
.dashboard {
    display: flex;
    gap: 2rem;
}

.sidebar {
    width: 20%;
    background-color: #1F1F1F;
    padding: 1rem;
    color: #E0E0E0;
}

.sidebar .nav {
    background-color: #333333;
    list-style: none;
    padding: 0;
}

.sidebar .nav li {
    margin: 1rem 0;
}

.sidebar .nav a {
    color: #E0E0E0;
    background-color: #1F1F1F;
    padding: 10px;
    display: block;
    border-radius: 5px;
    text-decoration: none;
}

.sidebar .nav a:hover {
    background-color: #333333;
    color: #FFFFFF;
}

.main-content {
    width: 75%;
    color: #E0E0E0;
}

.dashboard-cards {
    display: flex;
    gap: 1rem;
}

.dashboard-cards .card {
    flex: 1;
    padding: 1rem;
    background-color: #2E2E2E;
    border-radius: 5px;
    color: #E0E0E0;
}

.dashboard-cards .card h3 {
    color: #FFFFFF;
}

.dashboard-cards .card p, .dashboard-cards .card ul {
    color: #B0B0B0;
}
//  `userId`  localStorage
const userId = localStorage.getItem('userId');

//     
async function getUserData() {
    const token = localStorage.getItem('token');
    try {
        const response = await fetch(`http://127.0.0.1:8000/users/user/${userId}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            },
        });
        if (!response.ok) throw new Error(`Error fetching user data: ${response.status}`);
        const userData = await response.json();

        //   
        document.querySelector('#userName').textContent = `Welcome, ${userData.first_name} ${userData.last_name}!`;
        document.querySelector('#userEmail').textContent = userData.email;

        //   
        if (userData.tariff) {
            document.querySelector('#tariffInfo').textContent = `${userData.tariff.tag} - $${userData.tariff.price}`;
        } else {
            document.querySelector('#tariffInfo').textContent = 'No tariff information available';
        }

        // :      
        document.querySelector('#joinDate').textContent = `Joined on ${new Date(userData.start_time).toLocaleDateString()}`;

    } catch (error) {
        console.error("Failed to fetch user data:", error);
    }
}

//         5 
async function getUserPublications() {
    const token = localStorage.getItem('token');
    try {
        const response = await fetch(`http://127.0.0.1:8000/users/publications/${userId}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            },
        });
        if (!response.ok) throw new Error(`Error fetching publications: ${response.status}`);
        const publications = await response.json();

        const publicationsList = document.querySelector('#publicationsList');
        publicationsList.innerHTML = '';

        //    5 
        publications.slice(0, 5).forEach((publication) => {
            const listItem = document.createElement('li');
            listItem.textContent = `${publication.text} (Published at: ${publication.time})`;
            publicationsList.appendChild(listItem);
        });
    } catch (error) {
        console.error("Failed to fetch publications:", error);
    }
}

//       
document.addEventListener('DOMContentLoaded', () => {
    getUserData();
    getUserPublications();
});
document.addEventListener("DOMContentLoaded", () => {
    const form = document.getElementById("loginForm");
    form.addEventListener("submit", async (event) => {
        event.preventDefault();
        const formData = new FormData(form);
        try {
            const response = await fetch(form.action, {
                method: form.method,
                body: formData,
            });

            if (response.ok) {
                const data = await response.json(); // ,    userId    JSON
                const token = data.access_token; //  
                const userId = data.user_id; //  id 

                localStorage.setItem('token', token); //    localStorage
                localStorage.setItem('userId', userId); //  userId  localStorage

                window.location.href = "/dashboard"; //   
            } else {
                alert("Invalid login credentials");
            }
        } catch (error) {
            console.error("Error during login:", error);
        }
    });
});
{% include 'layout.html' %}

<div class="container">
    <div class="dashboard">
        <div class="sidebar">
            <ul class="nav">
                <li><a href="/user/profile">Profile</a></li>
                <li><a href="/publications">Publications</a></li>
                <li><a href="/settings">Settings</a></li>
                <li><a href="/logout">Logout</a></li>
            </ul>
        </div>

        <div class="main-content">
            <h1 id="userName">Welcome, User!</h1>
            <p id="userEmail">user@example.com</p>

            <p>Heres a summary of your account activities:</p>
            <div class="dashboard-cards">
                <div class="card">
                    <h3>Your Tariff Plan</h3>
                    <p id="tariffInfo">Tariff Information</p>
                </div>
                <div class="card">
                    <h3>Recent Publications</h3>
                    <ul id="publicationsList">
                        <!--     JS -->
                    </ul>
                </div>
                <div class="card">
                    <h3>Account Details</h3>
                    <p>Joined on <span id="joinDate">join_date</span></p>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="/static/js/dashboard.js"></script>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Telegram Bot DashBoard{% endblock %}</title>
    <link rel="stylesheet" href="/static/css/base.css">
    <link rel="stylesheet" href="/static/css/dashboard.css">
</head>
<body>
    <header>
        <h1>{% block header %}Telegram Bot DashBoard{% endblock %}</h1>
         <nav>
            {% if not is_dashboard %}
                <a href="/auth/register-page">Register</a>
            {% endif %}
        </nav>
    </header>
    <main>
        {% block content %}{% endblock %}
    </main>
    <script src="/static/js/scripts.js"></script>
</body>
</html>
{% extends "layout.html" %}

{% block title %}Login{% endblock %}

{% block content %}
<div class="container">
    <div class="card">
        <div class="card-header">
            Login
        </div>
        <div class="card-body">
            <form id="loginForm" method="POST" action="/auth/token">
                <div class="form-group">
                    <label>Username</label>
                    <input type="text" class="form-control" name="username" autocomplete="username" required>
                </div>
                <div class="form-group">
                    <label>Password</label>
                    <input type="password" class="form-control" name="password" autocomplete="current-password" required>
                </div>
                <button type="submit" class="btn btn-primary">Login</button>
            </form>
        </div>
        <div class="card-footer text-muted">
            <a href="/auth/register-page">Register?</a>
        </div>
    </div>
</div>
{% endblock %}